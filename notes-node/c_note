#include<stdio.h>
#define T 5

struct celula {
  int num;
  int pos;
  int nextL;
  int nextC;
};

typedef struct celula C;

void main() {
    int i, j, num = 2;
    C matriz[T][T];
    matriz[(T+1) / 2 - 1][(T+1) / 2 - 1].num = 1;
    matriz[(T+1) / 2 - 1][(T+1) / 2 - 1].pos = 0;
    matriz[(T+1) / 2 - 1][(T+1) / 2 - 1].nextL = (T + 1) / 2 - 1;
    matriz[(T+1) / 2 - 1][(T+1) / 2 - 1].nextC = (T + 1) / 2;
    for(i = 0; i < T; i++){
        for(j = 0; j < T; j++){
            if(i == j && i == (T +1) / 2 -1)
                continue;
            matriz[i][j].num = 0;
        }
    }    
    for(i = 0; i < T; i++){
        for(j = 0; j < T; j++){
            printf("%d\t", matriz[i][j].num);
            if(j+1 == T)
                printf("\n");
        }
    }
//   int matriz[T][T], i, j, num = 1, cont = 0, r = 0;
//   for(i = 0; i < T; i++){
//       for(j = 0; j < T; j++){
//           if(T % 2 != 0 && ((i+1 == (T+1) / 2) && (j+1 == (T+1) / 2))){
//               matriz[i][j] = num;
//               num++;
//           }else if(i+1 % 2 != 0  &&  i+1 < T && i+1 > (T+1) / 2 && j > 0 && j < i + 1){
//               matriz[i][j] = ((i+1) * (i-1)) + 2 + j;
//           }else if(i+1 == T){
//               matriz[i][j] = (T * (T - 2)) + 2 + cont;
//               cont++;
//           }else{
//               matriz[i][j] = 0;
//           }
//       }
//   }
//   for(i = 0; i < T; i++){
//       for(j = 0; j < T; j++){
//           printf("%d\t", matriz[i][j]);
//           if(j % (T - 1)  == 0 && j != 0)
//              printf("\n");
//       }
//   }   
}

int linha(C celula){
    
}

int coluna(C celula){
    
}

void Topo(C m, int l, int c){
    if(m[l+1][c] == 0){
        m[l][c].nextL = l+1;
        m[l][c].nextC = c;
    }else{
        m[l][c].nextL = l;
        m[l][c].nextC = c-1;
    }
}

void preencheProximo(C m[T][T]){
    int i, j, l, c;
    for(i = 1; i <= T*T; i++){
        if(i == 1){
            l = m[(T+1) / 2 - 1][(T+1) / 2 - 1].nextL;
            c = m[(T+1) / 2 - 1][(T+1) / 2 - 1].nextC;
            m[l][c].num = i + 1;
            m[l][c].pos = 1;
        }else{
            switch(m[l][c].pos){
                case 1:
                    Topo(m, l, c);
                    break;
                case 2:
                    Esquerda(m, l, c);
                    break;
                case 3:
                    Baixo(m, l, c);
                    break;
                case 4:
                    Esquerda(m, l, c);
                    break;
            }            
        }
            
    }
}
